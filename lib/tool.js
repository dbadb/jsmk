/* global jsmk */
var path = require("path");
var SettingsContainer = require("./settingscontainer.js").SettingsContainer;

var Semantics = {
    NoneToNone: "NoneToNone",
    OneToNone: "OneToNone",
    OneToOne: "OneToOne",
    ManyToOne: "ManyToOne",
    ManyToMany: "ManyToMany",
    CustomTrigger: "CustomTrigger",
};

var Role = // NB: stage and role, often correlated, are orthogonal
    {
        Archive: "Archive", // incl ar, tar, zip
        ArchiveDynamic: "ArchiveDynamic", // .so, .dll
        Extract: "Extract", // objcopy, un-archive
        Strip: "Strip", // symbol-strip, etc.
        Compile: "Compile", // c, rsl, uglify
        Link: "Link", // ->exe
        Clean: "Clean",
        Copy: "Copy",
        Test: "Test", // run test-suite, download to arduino, etc
        Benchmark: "Benchmark",
        Sync: "Sync", // git, perforce
        Reposit: "Reposit", // ftp, scp, rsync
        Deploy: "Deploy", // download to arduino, etc
        Report: "Report", // stats, etc
        Sign: "Sign",
    };

// A Tool is a SettingsContainer that embodies all the Settings
// associated with and individual tool.   Tool settings can be
// composed via inheritance or by explicitly combining with other
// SettingsContainers.
//
// Work is generated by composing the Tool settings with the Task settings.
//
class Tool extends SettingsContainer
{
    constructor(toolset, name, config)
    {
        super();
        this.m_toolset = toolset;
        this.m_name = name;
        this.m_role = config.Role;
        this.m_semantics = config.Semantics;
        this.m_dstExt = config.DstExt;
        this.m_actionStage = config.ActionStage ? config.ActionStage : "build";
        this.m_syntax = config.Syntax;
        this.m_outputNaming = config.OutputNaming || "general"; // "concise"
        this.MergeSettings(toolset); // apply toolset settings
        this.MergeSettings(config); // apply config settings
    }

    GetToolset()
    {
        return this.m_toolset;
    }

    GetRole()
    {
        return this.m_role;
    }

    ConfigureTaskSettings(task)
    {
        // jsmk.INFO(`Tool ${this.m_name} configure task: ${task.GetName()}`);
        task.MergeSettings(this);
    }

    // DstFilesFromSrc:
    //  given a list of fully-qualified src files, return a list
    //  of one or more dst file pathnames. Tools currently must follow
    //  many-to-many (eg compilation) and many-to-one pattern (eg link).
    //  For build-script (cli), tasks can override tool semantics and
    //  dstExtk
    DstFilesFromSrc(taskname, srcfiles, dstDir, 
                    semantics=null, dstExt=null)
    {
        var dstfiles = [];
        let s = semantics || this.m_semantics; // customScripts override semantics
        let ext = dstExt || this.m_dstExt;
        switch (s)
        {
            case Semantics.ManyToOne:
                var dstfile = this.buildDstFileName(taskname, dstDir, ext);
                dstfiles.push(dstfile);
                break;
            case Semantics.OneToOne:
            case Semantics.ManyToMany:
                var self = this;
                dstfiles = srcfiles ? srcfiles.map(function(srcfile)
                {
                    return self.buildDstFileName(srcfile, dstDir, ext);
                }) : [];
                // console.log("task outputs", dstfiles);
                break;
            case Semantics.OneToNone:
                break;
            case Semantics.NoneToNone:
                break;
            default:
                throw new Error(this.m_name +
                    ": Unknown tool semantics: " + s);
        }
        return dstfiles;
    }

    BeginStage(stage, task)
    {
        /* not all tools need implement BeginStage */
    }

    GetActionStage()
    {
        return this.m_actionStage;
    }

    // GenerateWork is a generator (ie: issues yield) of Promises
    * GenerateWork(stage, task, inputs, outputs)
    {
        jsmk.ERROR("tools must implement GenerateWork method");
        yield null;
    }

    EndStage(stage, task)
    {
        /* not all tools need implement EndStage */
    }

    // protected ---------------------------------------------
    // NB: currently ms/visualstudio 17 doesn't build full dependency files.
    outputIsDirty(output, inputs, cwd)
    {
        if(typeof inputs === "string")
            inputs = [inputs];
        let outfile = jsmk.path.isAbsolute(output) ? output :
                            jsmk.path.join(cwd, output);
        for(let input of inputs)
        {
            let ifile = jsmk.path.isAbsolute(input) ? input :
                jsmk.path.join(cwd, input);
            if(jsmk.file.newer(ifile, outfile))
            {
                jsmk.DEBUG(`${ifile} newer ${outfile}? 1`);
                return true;
            }
            else
            {
                jsmk.DEBUG(`${ifile} newer ${outfile}? 0`);
            }
        }
        return false;
    }

    isDir(fp)
    {
        return jsmk.file.isDir(fp);
    }

    // private -----------------------------------------------------------
    buildDstFileName(srcfile, dstDir, dstExt)
    {
        /*
         *  path.parse("core/chuck.y")
         *  { 
         *    root: '', 
         *    dir: 'core', 
         *    base: 'chuck.y', 
         *    ext: '.y', 
         *    name: 'chuck' 
         *  }
         */

        var srcp = path.parse(srcfile);
        srcp.dir = dstDir;
        // NB: esp8266's ld scripts assume that files are named like:
        //  foo.cpp.o, not foo.o. We can live with this right?
        // nb base is used by format...
        if(dstExt !== "")
        {
            srcp.ext = "." + dstExt;
            if(this.m_outputNaming == "concise")
                srcp.base = srcp.name + srcp.ext;
            else // "general"
                srcp.base = srcp.base + srcp.ext;
        }
        else
        {
            srcp.ext = "";
            if(this.m_outputNaming == "concise")
                srcp.base = srcp.name;
        }
        let result = jsmk.path.normalize(path.format(srcp));
        // jsmk.NOTICE(`${srcfile} -> ${result}`);
        return result;
    }
}

class ToolNop extends Tool
{
    constructor(toolset, name, config)
    {
        super(toolset, name, config);
    }

    * GenerateWork(stage, task, inputs, outputs)
    {
        yield null;
    }
}

// class variables, enums, etc
Tool.Semantics = Semantics;
Tool.Role = Role;
exports.Tool = Tool;
exports.ToolNop = ToolNop;
